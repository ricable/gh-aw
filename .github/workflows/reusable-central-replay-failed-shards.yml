name: Reusable Central Replay Failed Shards

on:
  workflow_call:
    inputs:
      failed_repos_json:
        description: JSON array of owner/repo values that failed in a previous run
        required: false
        default: "[]"
        type: string
      target_ref:
        description: Git ref used for replay checkout/build validation
        required: false
        default: main
        type: string
      max_replays:
        description: Maximum number of failed repositories to replay in one run
        required: false
        default: "10"
        type: string
    outputs:
      replay_targets_json:
        description: JSON array of replay targets selected for this run
        value: ${{ jobs.select_replays.outputs.replay_targets_json }}
      replay_count:
        description: Number of replay targets selected
        value: ${{ jobs.select_replays.outputs.replay_count }}

permissions:
  contents: read

jobs:
  select_replays:
    runs-on: ubuntu-latest
    outputs:
      replay_targets_json: ${{ steps.select.outputs.replay_targets_json }}
      replay_count: ${{ steps.select.outputs.replay_count }}
    steps:
      - id: select
        uses: actions/github-script@v7
        env:
          FAILED_REPOS_JSON: ${{ inputs.failed_repos_json }}
          MAX_REPLAYS: ${{ inputs.max_replays }}
        with:
          script: |
            const raw = process.env.FAILED_REPOS_JSON || '[]';
            const maxReplaysRaw = String(process.env.MAX_REPLAYS || '10').trim();
            const maxReplays = Number.parseInt(maxReplaysRaw, 10);

            if (!Number.isInteger(maxReplays) || maxReplays <= 0) {
              core.setFailed(`max_replays must be a positive integer, got '${maxReplaysRaw}'`);
              return;
            }

            let repos;
            try {
              repos = JSON.parse(raw);
            } catch (error) {
              core.setFailed(`failed_repos_json is not valid JSON: ${error.message}`);
              return;
            }

            if (!Array.isArray(repos)) {
              core.setFailed('failed_repos_json must be a JSON array');
              return;
            }

            const cleaned = [...new Set(repos.filter((repo) => typeof repo === 'string' && repo.includes('/')))];
            const selected = cleaned.slice(0, maxReplays);

            core.setOutput('replay_targets_json', JSON.stringify(selected));
            core.setOutput('replay_count', String(selected.length));

  deterministic_replay:
    needs: [select_replays]
    if: ${{ needs.select_replays.outputs.replay_count != '0' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        repo: ${{ fromJson(needs.select_replays.outputs.replay_targets_json) }}
    steps:
      - name: Checkout replay target repository
        uses: actions/checkout@v5
        with:
          repository: ${{ matrix.repo }}
          ref: ${{ inputs.target_ref }}
          token: ${{ secrets.REPO_TOKEN }}

      - name: Deterministic replay validation
        shell: bash
        run: |
          set -euo pipefail

          echo "Replaying failed target: ${{ matrix.repo }}"
          git rev-parse HEAD

          if [[ -f package.json ]]; then
            npm ci
            npm run --if-present build
          elif [[ -f go.mod ]]; then
            go build ./...
          else
            echo "No default build strategy detected; replay checkout validation completed."
          fi
