#!/usr/bin/env node

/**
 * Wasm Golden Test Runner
 *
 * Builds the gh-aw wasm module, loads it in Node.js, compiles workflow fixtures,
 * and compares the output against golden files generated by the Go test suite.
 *
 * Usage:
 *   node scripts/test-wasm-golden.mjs [--update]
 *
 * The --update flag regenerates golden files from wasm output.
 *
 * Prerequisites:
 *   - Go 1.23+ installed
 *   - Run `make build-wasm` first, or this script will build it
 */

import { readFileSync, readdirSync, writeFileSync, existsSync, mkdirSync } from "fs";
import { join, resolve, basename } from "path";
import { execSync } from "child_process";
import { createRequire } from "module";

const ROOT = resolve(import.meta.dirname, "..");
const FIXTURES_DIR = join(
  ROOT,
  "pkg/workflow/testdata/wasm_golden/fixtures"
);
const GOLDEN_DIR = join(
  ROOT,
  "pkg/workflow/testdata/wasm_golden"
);
const WASM_FILE = join(ROOT, "gh-aw.wasm");
const UPDATE_MODE = process.argv.includes("--update");

// ── Build wasm if needed ─────────────────────────────────────────────
function ensureWasmBuilt() {
  if (!existsSync(WASM_FILE)) {
    console.log("Building wasm module...");
    execSync("make build-wasm", { cwd: ROOT, stdio: "inherit" });
  }
  console.log(`Using wasm module: ${WASM_FILE}`);
}

// ── Load Go wasm_exec.js runtime ─────────────────────────────────────
function loadWasmExecJs() {
  const goRoot = execSync("go env GOROOT", { encoding: "utf8" }).trim();
  // Go 1.24+ moved wasm_exec.js from misc/wasm/ to lib/wasm/
  let wasmExecPath = join(goRoot, "lib/wasm/wasm_exec.js");
  if (!existsSync(wasmExecPath)) {
    wasmExecPath = join(goRoot, "misc/wasm/wasm_exec.js");
  }
  if (!existsSync(wasmExecPath)) {
    throw new Error(`wasm_exec.js not found in ${goRoot}/lib/wasm/ or ${goRoot}/misc/wasm/`);
  }
  // wasm_exec.js expects a global `require` for Node.js
  globalThis.require = createRequire(import.meta.url);
  // Load the wasm_exec.js script (it defines globalThis.Go)
  const script = readFileSync(wasmExecPath, "utf8");
  // Use indirect eval to run in global scope
  const fn = new Function(script);
  fn();
}

// ── Instantiate wasm module ──────────────────────────────────────────
async function instantiateWasm() {
  const go = new globalThis.Go();
  const wasmBytes = readFileSync(WASM_FILE);
  const result = await WebAssembly.instantiate(wasmBytes, go.importObject);
  // Start the Go runtime (it blocks, runs in background)
  go.run(result.instance);
  // Wait a moment for the Go runtime to register the global function
  await new Promise((r) => setTimeout(r, 200));

  if (typeof globalThis.compileWorkflow !== "function") {
    throw new Error(
      "compileWorkflow function not registered by wasm module. " +
        "Ensure cmd/gh-aw-wasm/main.go sets js.Global().Set('compileWorkflow', ...)"
    );
  }
  console.log("Wasm module loaded, compileWorkflow function available");
  return globalThis.compileWorkflow;
}

// ── Load virtual files for import resolution ────────────────────────
function loadVirtualFiles(fixtureFilename) {
  // Read the fixture to check for imports
  const content = readFileSync(join(FIXTURES_DIR, fixtureFilename), "utf8");
  const importMatch = content.match(/^imports:\s*\n((?:\s+-\s+.+\n?)+)/m);
  if (!importMatch) return null;

  const files = {};
  const imports = importMatch[1].match(/^\s+-\s+(.+)$/gm);
  if (!imports) return null;

  for (const imp of imports) {
    const path = imp.replace(/^\s+-\s+/, "").trim();
    const fullPath = join(FIXTURES_DIR, path);
    if (existsSync(fullPath)) {
      files[path] = readFileSync(fullPath, "utf8");
    }
  }

  return Object.keys(files).length > 0 ? files : null;
}

// ── Load fixtures ────────────────────────────────────────────────────
function loadFixtures() {
  const files = readdirSync(FIXTURES_DIR).filter((f) => f.endsWith(".md"));
  return files.map((f) => ({
    name: f.replace(/\.md$/, ""),
    filename: f,
    content: readFileSync(join(FIXTURES_DIR, f), "utf8"),
    virtualFiles: loadVirtualFiles(f),
  }));
}

// ── Load golden file ─────────────────────────────────────────────────
function loadGoldenFile(testName) {
  // Golden files follow the charmbracelet/x/exp/golden convention:
  // testdata/TestName/subtest_name.golden
  const goldenPath = join(
    GOLDEN_DIR,
    "TestWasmGolden_CompileFixtures",
    testName + ".golden"
  );
  if (!existsSync(goldenPath)) {
    return null;
  }
  return readFileSync(goldenPath, "utf8");
}

// ── Save wasm golden file ────────────────────────────────────────────
function saveWasmGoldenFile(testName, content) {
  const dir = join(GOLDEN_DIR, "WasmBinary");
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
  const goldenPath = join(dir, testName + ".golden");
  writeFileSync(goldenPath, content);
}

// ── Main test runner ─────────────────────────────────────────────────
async function main() {
  ensureWasmBuilt();
  loadWasmExecJs();
  const compileWorkflow = await instantiateWasm();
  const fixtures = loadFixtures();

  console.log(`\nRunning wasm golden tests on ${fixtures.length} fixtures...\n`);

  let passed = 0;
  let failed = 0;
  let skipped = 0;
  const failures = [];

  for (const fixture of fixtures) {
    process.stdout.write(`  ${fixture.name} ... `);

    try {
      const result = await compileWorkflow(fixture.content, fixture.virtualFiles, fixture.filename);

      if (result.error) {
        console.log("FAIL (compilation error)");
        failures.push({
          name: fixture.name,
          error: `Wasm compilation error: ${result.error}`,
        });
        failed++;
        continue;
      }

      const wasmYaml = result.yaml;

      if (UPDATE_MODE) {
        saveWasmGoldenFile(fixture.name, wasmYaml);
        console.log("UPDATED");
        passed++;
        continue;
      }

      // Compare against Go string API golden file
      const goldenYaml = loadGoldenFile(fixture.name);
      if (goldenYaml === null) {
        console.log("SKIP (no golden file, run Go tests first)");
        skipped++;
        continue;
      }

      if (wasmYaml === goldenYaml) {
        console.log("PASS");
        passed++;
      } else {
        console.log("FAIL (output differs from golden)");

        // Find first difference
        const wasmLines = wasmYaml.split("\n");
        const goldenLines = goldenYaml.split("\n");
        for (
          let i = 0;
          i < Math.min(wasmLines.length, goldenLines.length);
          i++
        ) {
          if (wasmLines[i] !== goldenLines[i]) {
            failures.push({
              name: fixture.name,
              error: `First diff at line ${i + 1}:\n  wasm:   ${JSON.stringify(wasmLines[i])}\n  golden: ${JSON.stringify(goldenLines[i])}`,
            });
            break;
          }
        }
        if (wasmLines.length !== goldenLines.length) {
          failures.push({
            name: fixture.name,
            error:
              (failures.length > 0 ? failures[failures.length - 1].error + "\n" : "") +
              `Line count: wasm=${wasmLines.length}, golden=${goldenLines.length}`,
          });
        }
        failed++;
      }
    } catch (err) {
      console.log("ERROR");
      failures.push({
        name: fixture.name,
        error: `Exception: ${err.message}`,
      });
      failed++;
    }
  }

  // Summary
  console.log(`\n${"=".repeat(60)}`);
  console.log(
    `Results: ${passed} passed, ${failed} failed, ${skipped} skipped (${fixtures.length} total)`
  );

  if (failures.length > 0) {
    console.log(`\nFailures:`);
    for (const f of failures) {
      console.log(`\n  ${f.name}:`);
      console.log(`    ${f.error.replace(/\n/g, "\n    ")}`);
    }
  }

  if (UPDATE_MODE) {
    console.log(`\nWasm golden files updated in ${GOLDEN_DIR}/WasmBinary/`);
  }

  console.log();
  process.exit(failed > 0 ? 1 : 0);
}

main().catch((err) => {
  console.error("Fatal error:", err);
  process.exit(2);
});
