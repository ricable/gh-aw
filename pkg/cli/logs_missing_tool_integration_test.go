//go:build integration

package cli

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/github/gh-aw/pkg/testutil"

	"github.com/github/gh-aw/pkg/constants"
)

// TestMissingToolDetectionIntegration tests the complete flow from artifact file to report
func TestMissingToolDetectionIntegration(t *testing.T) {
	// Create a temporary directory structure mimicking a real workflow run
	tmpDir := testutil.TempDir(t, "test-*")
	runDir := filepath.Join(tmpDir, "run-18635648039")
	err := os.MkdirAll(runDir, 0755)
	if err != nil {
		t.Fatalf("Failed to create test directory: %v", err)
	}

	// Create agent_output.json with the actual data from the workflow run
	agentOutputContent := `{
  "items": [
    {
      "type": "missing_tool",
      "tool": "run_python_query (python-code-interpreter MCP)",
      "reason": "Task requires Python execution via MCP server but tool is not available. Bash execution is blocked.",
      "alternatives": "Direct Python/matplotlib execution through available MCP servers or unblocked bash access",
      "timestamp": "2025-10-19T20:29:26.971Z"
    }
  ],
  "errors": []
}`

	agentOutputPath := filepath.Join(runDir, string(constants.AgentOutputArtifactName))
	err = os.WriteFile(agentOutputPath, []byte(agentOutputContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write agent_output.json: %v", err)
	}

	// Create aw_info.json
	awInfoContent := `{
  "engine_id": "copilot",
  "workflow_name": "Dev",
  "staged": false
}`
	awInfoPath := filepath.Join(runDir, "aw_info.json")
	err = os.WriteFile(awInfoPath, []byte(awInfoContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write aw_info.json: %v", err)
	}

	// Create test run
	testRun := WorkflowRun{
		DatabaseID:   18635648039,
		WorkflowName: "Dev",
	}

	// Extract missing tools
	missingTools, err := extractMissingToolsFromRun(runDir, testRun, false)
	if err != nil {
		t.Fatalf("Error extracting missing tools: %v", err)
	}

	// Verify results
	if len(missingTools) != 1 {
		t.Errorf("Expected 1 missing tool, got %d", len(missingTools))
		return
	}

	tool := missingTools[0]
	expectedTool := "run_python_query (python-code-interpreter MCP)"
	if tool.Tool != expectedTool {
		t.Errorf("Expected tool '%s', got '%s'", expectedTool, tool.Tool)
	}

	expectedReason := "Task requires Python execution via MCP server but tool is not available. Bash execution is blocked."
	if tool.Reason != expectedReason {
		t.Errorf("Expected reason '%s', got '%s'", expectedReason, tool.Reason)
	}

	expectedAlternatives := "Direct Python/matplotlib execution through available MCP servers or unblocked bash access"
	if tool.Alternatives != expectedAlternatives {
		t.Errorf("Expected alternatives '%s', got '%s'", expectedAlternatives, tool.Alternatives)
	}

	if tool.WorkflowName != testRun.WorkflowName {
		t.Errorf("Expected workflow name '%s', got '%s'", testRun.WorkflowName, tool.WorkflowName)
	}

	if tool.RunID != testRun.DatabaseID {
		t.Errorf("Expected run ID %d, got %d", testRun.DatabaseID, tool.RunID)
	}
}

// TestMissingToolTypeConsistency ensures the type field is consistent across the codebase.
// This test documents that the missing tool type must be "missing_tool" (with underscore)
// to match the format generated by JavaScript code in agent workflows. The JavaScript code
// that creates agent_output.json uses "missing_tool" as the type identifier.
func TestMissingToolTypeConsistency(t *testing.T) {
	tmpDir := testutil.TempDir(t, "test-*")
	runDir := filepath.Join(tmpDir, "test-run")
	err := os.MkdirAll(runDir, 0755)
	if err != nil {
		t.Fatalf("Failed to create test directory: %v", err)
	}

	testRun := WorkflowRun{
		DatabaseID:   12345,
		WorkflowName: "Test",
	}

	// Test with correct type format (underscore) - this should match and extract the tool
	correctTypeContent := `{
  "items": [
    {
      "type": "missing_tool",
      "tool": "test_tool",
      "reason": "Test reason"
    }
  ]
}`
	agentOutputPath := filepath.Join(runDir, string(constants.AgentOutputArtifactName))
	err = os.WriteFile(agentOutputPath, []byte(correctTypeContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	tools, err := extractMissingToolsFromRun(runDir, testRun, false)
	if err != nil {
		t.Fatalf("Error extracting with correct type: %v", err)
	}
	if len(tools) != 1 {
		t.Errorf("Expected 1 tool with correct type 'missing_tool', got %d", len(tools))
	}

	// Test with incorrect type format (hyphen) - this should NOT match
	// The hyphen format was the source of the original bug
	incorrectTypeContent := `{
  "items": [
    {
      "type": "missing-tool",
      "tool": "test_tool",
      "reason": "Test reason"
    }
  ]
}`
	err = os.WriteFile(agentOutputPath, []byte(incorrectTypeContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	tools, err = extractMissingToolsFromRun(runDir, testRun, false)
	if err != nil {
		t.Fatalf("Error extracting with incorrect type: %v", err)
	}
	if len(tools) != 0 {
		t.Errorf("Expected 0 tools with incorrect type 'missing-tool', got %d", len(tools))
	}
}

// TestMissingToolFlattenedStructure tests the new flattened artifact structure
// where agent_output.json is at root after artifact flattening
func TestMissingToolFlattenedStructure(t *testing.T) {
	tmpDir := testutil.TempDir(t, "test-*")
	runDir := filepath.Join(tmpDir, "run-flattened")
	err := os.MkdirAll(runDir, 0755)
	if err != nil {
		t.Fatalf("Failed to create test directory: %v", err)
	}

	// Create agent_output.json at root (new flattened structure)
	agentOutputContent := `{
  "items": [
    {
      "type": "missing_tool",
      "tool": "test_tool_flattened",
      "reason": "Test reason for flattened structure",
      "alternatives": "Use alternative approach",
      "timestamp": "2025-01-05T00:00:00.000Z"
    }
  ],
  "errors": []
}`

	// Use the actual filename: agent_output.json (with underscore and .json extension)
	agentOutputPath := filepath.Join(runDir, "agent_output.json")
	err = os.WriteFile(agentOutputPath, []byte(agentOutputContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write agent_output.json: %v", err)
	}

	// Create test run
	testRun := WorkflowRun{
		DatabaseID:   99999,
		WorkflowName: "Flattened Test",
	}

	// Extract missing tools - should find the file at root
	missingTools, err := extractMissingToolsFromRun(runDir, testRun, false)
	if err != nil {
		t.Fatalf("Error extracting missing tools from flattened structure: %v", err)
	}

	// Verify results
	if len(missingTools) != 1 {
		t.Errorf("Expected 1 missing tool from flattened structure, got %d", len(missingTools))
		return
	}

	tool := missingTools[0]
	expectedTool := "test_tool_flattened"
	if tool.Tool != expectedTool {
		t.Errorf("Expected tool '%s', got '%s'", expectedTool, tool.Tool)
	}

	expectedReason := "Test reason for flattened structure"
	if tool.Reason != expectedReason {
		t.Errorf("Expected reason '%s', got '%s'", expectedReason, tool.Reason)
	}

	if tool.WorkflowName != testRun.WorkflowName {
		t.Errorf("Expected workflow name '%s', got '%s'", testRun.WorkflowName, tool.WorkflowName)
	}
}
